diff --git a/temp/q-e-qe-7.5/upflib/xmltools.f90 b/q-e-qe-7.5/upflib/xmltools.f90
index f8b7ec4..9aabf22 100644
--- a/temp/q-e-qe-7.5/upflib/xmltools.f90
+++ b/q-e-qe-7.5/upflib/xmltools.f90
@@ -86,6 +86,7 @@ MODULE xmltools
   !   2   error parsing file
   !   3   line too long
   !   4   too many levels of tags
+  !   5   empty tag passed to xmlr_opentag (fatal error)
   ! 
   ! Error codes returned by xmlw_opentag / xml_writetag:
   !   0     tag open and/or written (no error)
@@ -129,13 +130,14 @@ CONTAINS
     INTEGER, INTENT(OUT) :: attrval_i
     !
     CHARACTER(LEN=80) :: attrval_c
+    INTEGER :: iostat_val
     !
     CALL get_c_attr ( attrname, attrval_c )
     if ( len_trim(attrval_c) > 0 ) then
-       READ (attrval_c,*, err=1) attrval_i
-       return
-1      print '("Error reading attribute ",a,": expected integer, found ",a)', &
-            trim(attrname), trim(attrval_c)
+       READ (attrval_c,*, iostat=iostat_val) attrval_i
+       if (iostat_val == 0) then
+          return
+       end if
     end if
     attrval_i = 0
     !
@@ -198,8 +200,12 @@ CONTAINS
     ! search for attribute name in attrlist: attr1="val1" attr2="val2" ...
     !
     attrval_c = ''
-    if ( .not. allocated(attrlist) ) return
-    if ( len_trim(attrlist) < 1 ) return
+    if ( .not. allocated(attrlist) ) then
+       return
+    end if
+    if ( len_trim(attrlist) < 1 ) then
+       return
+    end if
     !
     j0 = 1
     do while ( j0 < len_trim(attrlist) )
@@ -720,13 +726,25 @@ CONTAINS
   ! To be used in conjunction with routines in module xmlw to write xml
   !
   function i2c (i) result (c)
+    !
+    ! MinGW-safe version: returns fixed-length CHARACTER instead of allocatable
+    ! to avoid empty string bugs on MinGW gfortran
+    !
     integer, intent(in) :: i
-    character(len=:), allocatable :: c
-    character(len=11) :: caux
+    character(len=32) :: c  ! Fixed length, large enough for any integer
+    character(len=32) :: caux
+    integer :: lt
     !
-    write(caux,'(i11)') i
+    ! Write integer to fixed buffer
+    write(caux,'(I0)') i
     c = trim(adjustl(caux))
     !
+    ! Safety check: ensure result is non-empty for valid input
+    lt = len_trim(c)
+    if (lt == 0) then
+       ERROR STOP 'i2c: empty result'
+    end if
+    !
   end function i2c
   
   function l2c (l) result (c)
@@ -1073,6 +1091,36 @@ CONTAINS
     ntry =0
     if ( allocated(attrlist) ) deallocate (attrlist)
     lt = len_trim(tag)
+    
+    ! Guard: detect empty or whitespace-only tag calls (causes "match any '<'" bug)
+    if (lt == 0) then
+       print *, '========================================'
+       print *, 'FATAL: xmlr_opentag called with empty/whitespace tag'
+       print *, '========================================'
+       print *, 'Tag value (repr): [', tag, ']'
+       print *, 'Tag length: ', len(tag)
+       print *, 'Trimmed length: ', lt
+       print *, 'Current state:'
+       print *, '  xmlunit = ', xmlunit
+       print *, '  nlevel = ', nlevel
+       if (nlevel >= 0 .and. nlevel <= maxlevel) then
+          print *, '  Current open tags:'
+          do i = 0, nlevel
+             if (len_trim(open_tags(i)) > 0) then
+                print *, '    level ', i, ': [', trim(open_tags(i)), ']'
+             end if
+          end do
+       end if
+       print *, 'Caller should pass a valid non-empty XML tag name'
+       print *, 'Compile with -g -fbacktrace and run to get stack trace'
+       print *, '========================================'
+       if (present(ierr)) then
+          ierr = 5  ! New error code for empty tag
+          return
+       else
+          ERROR STOP 'xmlr_opentag: empty tag - compile with -fbacktrace for stack trace'
+       end if
+    end if
     !
  1  ntry = ntry+1
     stat=0
@@ -1212,6 +1260,9 @@ CONTAINS
           if ( ntry == 1 ) go to 1
        else
           print *, 'end of file reached, tag '//trim(tag)//' not found'
+          ! Defensive fix: rewind to prevent "Read past ENDFILE record" crash
+          ! This prevents the hard crash but does not fix the root cause
+          rewind(xmlunit)
        end if
     else
        print *, 'xmlr_opentag: severe parsing error'
