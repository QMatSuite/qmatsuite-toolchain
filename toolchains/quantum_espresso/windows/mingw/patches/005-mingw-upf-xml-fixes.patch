diff --git a/upflib/xmltools.f90 b/upflib/xmltools.f90
index f8b7ec4..9aabf22 100644
--- a/upflib/xmltools.f90
+++ b/upflib/xmltools.f90
@@ -86,6 +86,7 @@ MODULE xmltools
   !   2   error parsing file
   !   3   line too long
   !   4   too many levels of tags
+  !   5   empty tag passed to xmlr_opentag (fatal error)
   ! 
   ! Error codes returned by xmlw_opentag / xml_writetag:
   !   0     tag open and/or written (no error)
@@ -129,13 +130,14 @@ CONTAINS
     INTEGER, INTENT(OUT) :: attrval_i
     !
     CHARACTER(LEN=80) :: attrval_c
+    INTEGER :: iostat_val
     !
     CALL get_c_attr ( attrname, attrval_c )
     if ( len_trim(attrval_c) > 0 ) then
-       READ (attrval_c,*, err=1) attrval_i
-       return
-1      print '("Error reading attribute ",a,": expected integer, found ",a)', &
-            trim(attrname), trim(attrval_c)
+       READ (attrval_c,*, iostat=iostat_val) attrval_i
+       if (iostat_val == 0) then
+          return
+       end if
     end if
     attrval_i = 0
     !
@@ -198,8 +200,12 @@ CONTAINS
     ! search for attribute name in attrlist: attr1="val1" attr2="val2" ...
     !
     attrval_c = ''
-    if ( .not. allocated(attrlist) ) return
-    if ( len_trim(attrlist) < 1 ) return
+    if ( .not. allocated(attrlist) ) then
+       return
+    end if
+    if ( len_trim(attrlist) < 1 ) then
+       return
+    end if
     !
     j0 = 1
     do while ( j0 < len_trim(attrlist) )
@@ -720,13 +726,25 @@ CONTAINS
   ! To be used in conjunction with routines in module xmlw to write xml
   !
   function i2c (i) result (c)
+    !
+    ! MinGW-safe version: returns fixed-length CHARACTER instead of allocatable
+    ! to avoid empty string bugs on MinGW gfortran
+    !
     integer, intent(in) :: i
-    character(len=:), allocatable :: c
-    character(len=11) :: caux
+    character(len=32) :: c  ! Fixed length, large enough for any integer
+    character(len=32) :: caux
+    integer :: lt
     !
-    write(caux,'(i11)') i
+    ! Write integer to fixed buffer
+    write(caux,'(I0)') i
     c = trim(adjustl(caux))
     !
+    ! Safety check: ensure result is non-empty for valid input
+    lt = len_trim(c)
+    if (lt == 0) then
+       ERROR STOP 'i2c: empty result'
+    end if
+    !
   end function i2c
   
   function l2c (l) result (c)
@@ -1073,6 +1091,36 @@ CONTAINS
     ntry =0
     if ( allocated(attrlist) ) deallocate (attrlist)
     lt = len_trim(tag)
+    
+    ! Guard: detect empty or whitespace-only tag calls (causes "match any '<'" bug)
+    if (lt == 0) then
+       print *, '========================================'
+       print *, 'FATAL: xmlr_opentag called with empty/whitespace tag'
+       print *, '========================================'
+       print *, 'Tag value (repr): [', tag, ']'
+       print *, 'Tag length: ', len(tag)
+       print *, 'Trimmed length: ', lt
+       print *, 'Current state:'
+       print *, '  xmlunit = ', xmlunit
+       print *, '  nlevel = ', nlevel
+       if (nlevel >= 0 .and. nlevel <= maxlevel) then
+          print *, '  Current open tags:'
+          do i = 0, nlevel
+             if (len_trim(open_tags(i)) > 0) then
+                print *, '    level ', i, ': [', trim(open_tags(i)), ']'
+             end if
+          end do
+       end if
+       print *, 'Caller should pass a valid non-empty XML tag name'
+       print *, 'Compile with -g -fbacktrace and run to get stack trace'
+       print *, '========================================'
+       if (present(ierr)) then
+          ierr = 5  ! New error code for empty tag
+          return
+       else
+          ERROR STOP 'xmlr_opentag: empty tag - compile with -fbacktrace for stack trace'
+       end if
+    end if
     !
  1  ntry = ntry+1
     stat=0
@@ -1212,6 +1260,9 @@ CONTAINS
           if ( ntry == 1 ) go to 1
        else
           print *, 'end of file reached, tag '//trim(tag)//' not found'
+          ! Defensive fix: rewind to prevent "Read past ENDFILE record" crash
+          ! This prevents the hard crash but does not fix the root cause
+          rewind(xmlunit)
        end if
     else
        print *, 'xmlr_opentag: severe parsing error'
diff --git a/upflib/read_upf_new.f90 b/upflib/read_upf_new.f90
index b84c633..66daff2 100644
--- a/upflib/read_upf_new.f90
+++ b/upflib/read_upf_new.f90
@@ -44,6 +44,8 @@ CONTAINS
     !! ierr=1-4 : error reading PP file
     !! ierr= 81 : error opening PP file
     !
+    CHARACTER(LEN=64) :: tag_buf  ! Fixed-length buffer for tag names (MinGW-safe)
+    !
     iun = xml_open_file ( filename )
     if ( iun == -1 ) THEN
        ierr = 81
@@ -85,14 +87,16 @@ CONTAINS
     !! FIXME: this is needed only if the nonlinear core correction is used,
     !! FIXME: but with PAW the pseudo-core charge is used also if no nlcc
     IF(upf%nlcc) then
-       CALL xmlr_readtag( capitalize_if_v2('pp_nlcc'), &
+       CALL capitalize_if_v2_into('pp_nlcc', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), &
             upf%rho_atc(:) )
     else
        upf%rho_atc(:) = 0.0_dp
     end if
     IF( .NOT. upf%tcoulombp) then
        allocate ( upf%vloc(upf%mesh) )
-       CALL xmlr_readtag( capitalize_if_v2('pp_local'), &
+       CALL capitalize_if_v2_into('pp_local', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), &
             upf%vloc(:), ierr )
        !
        ! existing PP files may have pp_nlcc first, pp_local later,
@@ -115,7 +119,8 @@ CONTAINS
     if ( ierr > 0 ) go to 10
     !
     ALLOCATE( upf%rho_at(1:upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_rhoatom'), &
+    CALL capitalize_if_v2_into('pp_rhoatom', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%rho_at(1:upf%mesh) )
     !
     CALL read_pp_metagga ( upf, ierr)
@@ -146,28 +151,59 @@ CONTAINS
 
   END SUBROUTINE read_upf_new
   !
-  FUNCTION capitalize_if_v2 ( strin ) RESULT ( strout )
+  SUBROUTINE capitalize_if_v2_into ( strin, v2_flag, strout )
     !
-    ! returns a capitalized string for UPF v.2, the same string otherwise
+    ! Robust MinGW-safe version: writes capitalized string for UPF v.2, 
+    ! same string otherwise, into fixed-length output buffer.
     ! (UPF v.2 uses capitalized tags, UPF with schema use lowercase)
     !
+    ! This subroutine avoids allocatable CHARACTER returns that cause
+    ! empty-tag bugs on MinGW gfortran.
+    !
     USE upf_utils, ONLY: capital
     IMPLICIT NONE
-    CHARACTER(LEN=*) :: strin
+    CHARACTER(LEN=*), INTENT(IN)  :: strin
+    LOGICAL,          INTENT(IN)  :: v2_flag
+    CHARACTER(LEN=*), INTENT(OUT) :: strout
     !
-    INTEGER :: n
-    CHARACTER(LEN=:), ALLOCATABLE :: strout
+    INTEGER :: n, lt, lout
     !
-    IF ( v2 ) THEN
-       strout = ''
-       DO n = 1,LEN_TRIM(strin)
-          strout = strout // capital(strin(n:n))
+    ! Initialize output to empty
+    strout = ''
+    !
+    ! Get trimmed input length
+    lt = LEN_TRIM(strin)
+    lout = LEN(strout)
+    !
+    ! Guard: detect empty input
+    IF (lt == 0) THEN
+       RETURN
+    END IF
+    !
+    ! Guard: ensure output buffer is large enough
+    IF (lout < lt) THEN
+       ERROR STOP 'capitalize_if_v2_into: buffer overflow'
+    END IF
+    !
+    IF ( v2_flag ) THEN
+       ! UPF v.2: capitalize each character
+       ! Use direct character assignment (NO concatenation)
+       DO n = 1, lt
+          strout(n:n) = capital(strin(n:n))
        END DO
+       ! Pad remainder with blanks (already done by initialization)
     ELSE
-       strout = TRIM(strin)
+       ! UPF schema: copy trimmed input
+       strout(1:lt) = strin(1:lt)
+       ! Remainder already blank from initialization
+    END IF
+    !
+    ! Final safety check: ensure result is non-empty
+    IF (LEN_TRIM(strout) == 0 .AND. lt > 0) THEN
+       ERROR STOP 'capitalize_if_v2_into: empty result'
     END IF
     !
-  END FUNCTION capitalize_if_v2
+  END SUBROUTINE capitalize_if_v2_into
   !--------------------------------------------------------
   SUBROUTINE read_pp_header_schema ( upf )
     !--------------------------------------------------------
@@ -175,7 +211,10 @@ CONTAINS
     IMPLICIT NONE
     TYPE(pseudo_upf), INTENT(INOUT) :: upf ! the pseudo data
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_header') )
+    CHARACTER(LEN=64) :: tag_buf
+    !
+    CALL capitalize_if_v2_into('pp_header', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     !
     CALL xmlr_readtag( 'element', upf%psd )
     CALL xmlr_readtag( 'z_valence', upf%zp )
@@ -213,8 +252,11 @@ CONTAINS
     TYPE(pseudo_upf), INTENT(INOUT) :: upf ! the pseudo data
     !
     CHARACTER(LEN=1) :: dummy
+    CHARACTER(LEN=64) :: tag_buf
     !
-    CALL xmlr_readtag ( capitalize_if_v2('pp_header'), dummy )
+    ! Robust MinGW-safe tag handling: use fixed-length buffer
+    CALL capitalize_if_v2_into('pp_header', v2, tag_buf)
+    CALL xmlr_readtag ( TRIM(tag_buf), dummy )
     CALL get_attr ('generated', upf%generated)
     CALL get_attr ('author', upf%author)
     CALL get_attr ('date', upf%date)
@@ -252,8 +294,10 @@ CONTAINS
     IMPLICIT NONE
     TYPE(pseudo_upf),INTENT(INOUT) :: upf ! the pseudo data
     integer :: mesh
+    CHARACTER(LEN=64) :: tag_buf
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_mesh') )
+    CALL capitalize_if_v2_into('pp_mesh', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     CALL get_attr ( 'mesh', mesh )
     if ( mesh == 0 ) THEN
 #if defined (__debug)
@@ -270,9 +314,17 @@ CONTAINS
     CALL get_attr ( 'rmax', upf%rmax )
     CALL get_attr ( 'zmesh', upf%zmesh )
     allocate ( upf%r(1:upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_r'), upf%r(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_r', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%r(1:upf%mesh) )
+    IF (SIZE(upf%r) == 0) THEN
+       ERROR STOP 'read_pp_mesh: empty r array'
+    END IF
     allocate ( upf%rab(1:upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_rab'), upf%rab(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_rab', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%rab(1:upf%mesh) )
+    IF (SIZE(upf%rab) == 0) THEN
+       ERROR STOP 'read_pp_mesh: empty rab array'
+    END IF
     !
     CALL xmlr_closetag( ) ! end pp_mesh
     !
@@ -288,6 +340,8 @@ CONTAINS
     !
     INTEGER :: nb, ind, l, j
     CHARACTER(LEN=9) :: tag
+    CHARACTER(LEN=64) :: tag_buf
+    CHARACTER(LEN=32) :: nbuf  ! For MinGW-safe tag construction
     real(dp), allocatable :: vnl(:)
     !
     IF ( upf%typ == "SL" ) THEN
@@ -298,7 +352,8 @@ CONTAINS
           ALLOCATE(upf%vnl(upf%mesh,0:upf%lmax,1))
        end if
        allocate ( vnl(1:upf%mesh) )
-       CALL xmlr_opentag( capitalize_if_v2('pp_semilocal') )       
+       CALL capitalize_if_v2_into('pp_semilocal', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )       
        !
        tag = 'vnl'
        DO nb = 1,upf%nbeta
@@ -306,7 +361,9 @@ CONTAINS
              ! NOTA BENE: v2 format follows available PP files, written 
              ! using original write_upf_v2; not FoX-based write_upf_v2
              IF ( nb - 1 == upf%lloc ) CYCLE
-             tag = 'PP_VNL.'//i2c(nb-1)
+             ! MinGW-safe tag construction
+             WRITE(nbuf,'(I0)') nb-1
+             tag = 'PP_VNL.' // TRIM(nbuf)
           END IF
           CALL xmlr_readtag( tag, vnl, ierr )
           if ( ierr /= 0 ) then
@@ -346,6 +403,8 @@ CONTAINS
     LOGICAL :: isnull
     INTEGER :: nb, ind, l, l_, ln, lm, mb, nmb
     CHARACTER(LEN=15) :: tag
+    CHARACTER(LEN=64) :: tag_buf
+    CHARACTER(LEN=32) :: nbuf, nbuf1, nbuf2, nbuf3  ! For MinGW-safe tag construction
     REAL(dp), ALLOCATABLE :: aux(:)
     !
     nb = upf%nbeta
@@ -369,16 +428,28 @@ CONTAINS
        RETURN
     END IF
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_nonlocal') )
+    CALL capitalize_if_v2_into('pp_nonlocal', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     !
     DO nb = 1,upf%nbeta
        !
        IF ( v2 ) THEN
-          tag = 'PP_BETA.'//i2c(nb)
+          ! MinGW-safe tag construction: use direct WRITE instead of i2c()
+          ! This avoids allocatable character issues on MinGW gfortran
+          WRITE(nbuf,'(I0)') nb
+          tag = 'PP_BETA.' // TRIM(nbuf)
+          ! Safety check: ensure tag is non-empty
+          IF (LEN_TRIM(tag) == 0) THEN
+             ERROR STOP 'read_pp_nonlocal: empty tag after construction'
+          END IF
        ELSE
           tag = 'pp_beta'
        END IF
        CALL xmlr_readtag( tag, upf%beta(1:upf%mesh,nb) )
+       ! Robust check: ensure array is non-empty
+       IF (SIZE(upf%beta(1:upf%mesh,nb)) == 0) THEN
+          ERROR STOP 'read_pp_nonlocal: empty beta array'
+       END IF
        CALL get_attr('index', mb)
        ! not-so-strict test: index is absent or incorrect in some UPF v.2 files
        IF ( .NOT. v2 .AND. nb /= mb ) then
@@ -388,6 +459,10 @@ CONTAINS
        end if
        CALL get_attr('label', upf%els_beta(nb))
        CALL get_attr('angular_momentum', upf%lll(nb))
+       ! Robust check: ensure angular_momentum is valid (0 <= l <= lmax)
+       IF (upf%lll(nb) < 0 .OR. upf%lll(nb) > upf%lmax) THEN
+          ERROR STOP 'read_pp_nonlocal: invalid angular_momentum'
+       END IF
        IF ( .NOT. v2 .AND. upf%has_so ) &
             CALL get_attr('tot_ang_mom', upf%jjj(nb))
        CALL get_attr('cutoff_radius_index', upf%kbeta(nb))
@@ -404,12 +479,14 @@ CONTAINS
     !
     ! pp_dij (D_lm matrix)
     !
-    CALL xmlr_readtag ( capitalize_if_v2 ('pp_dij'), upf%dion )
+    CALL capitalize_if_v2_into('pp_dij', v2, tag_buf)
+    CALL xmlr_readtag ( TRIM(tag_buf), upf%dion )
     !
     ! pp_augmentation
     !
     IF (upf%tvanp .or. upf%tpawp) THEN
-       CALL xmlr_opentag( capitalize_if_v2('pp_augmentation') )
+       CALL capitalize_if_v2_into('pp_augmentation', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
        !
        IF ( v2 ) THEN
           CALL get_attr ( 'q_with_l', upf%q_with_l )
@@ -435,11 +512,13 @@ CONTAINS
           ENDIF
        ENDIF
        !
-       CALL xmlr_readtag( capitalize_if_v2('pp_q'), upf%qqq )
+       CALL capitalize_if_v2_into('pp_q', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), upf%qqq )
        !
        IF ( upf%tpawp ) THEN
           ALLOCATE ( upf%paw%augmom(1:upf%nbeta,1:upf%nbeta,0:2*upf%lmax) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_multipoles'), upf%paw%augmom )
+          CALL capitalize_if_v2_into('pp_multipoles', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf), upf%paw%augmom )
        ENDIF
        !
        ! read polinomial coefficients for Q_ij expansion at small radius
@@ -481,7 +560,11 @@ CONTAINS
                    IF( upf%tpawp ) isnull = (abs(upf%paw%augmom(nb,mb,l)) < upf%qqq_eps)
                    IF(isnull) CYCLE loop_on_l
                    IF ( v2 ) THEN
-                      tag = 'PP_QIJL.'//i2c(nb)//'.'//i2c(mb)//'.'//i2c(l)
+                      ! MinGW-safe tag construction
+                      WRITE(nbuf1,'(I0)') nb
+                      WRITE(nbuf2,'(I0)') mb
+                      WRITE(nbuf3,'(I0)') l
+                      tag = 'PP_QIJL.' // TRIM(nbuf1) // '.' // TRIM(nbuf2) // '.' // TRIM(nbuf3)
                    ELSE
                       tag = 'pp_qijl'
                    END IF
@@ -506,7 +589,10 @@ CONTAINS
                 IF  ( upf%tpawp ) isnull = ( abs(upf%qqq(nb,mb)) < upf%qqq_eps )
                 IF (isnull) CYCLE loop_on_mb
                 IF ( v2 ) THEN
-                   tag = 'PP_QIJ.'//i2c(nb)//'.'//i2c(mb)
+                   ! MinGW-safe tag construction
+                   WRITE(nbuf1,'(I0)') nb
+                   WRITE(nbuf2,'(I0)') mb
+                   tag = 'PP_QIJ.' // TRIM(nbuf1) // '.' // TRIM(nbuf2)
                 ELSE
                    tag = 'pp_qij'
                 END IF
@@ -546,6 +632,8 @@ CONTAINS
     !
     INTEGER :: nw, ind, l
     CHARACTER(LEN=9) :: tag
+    CHARACTER(LEN=64) :: tag_buf
+    CHARACTER(LEN=32) :: nbuf  ! For MinGW-safe tag construction
     !
     allocate ( upf%chi(1:upf%mesh,upf%nwfc) )
     allocate ( upf%els(upf%nwfc), &
@@ -557,14 +645,25 @@ CONTAINS
                 upf%epseu(upf%nwfc) )
     IF ( upf%has_so ) allocate ( upf%jchi(upf%nwfc) )
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_pswfc') )
+    CALL capitalize_if_v2_into('pp_pswfc', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     DO nw=1,upf%nwfc
        IF ( v2 ) THEN
-          tag = 'PP_CHI.'//i2c(nw)
+          ! MinGW-safe tag construction: use direct WRITE instead of i2c()
+          WRITE(nbuf,'(I0)') nw
+          tag = 'PP_CHI.' // TRIM(nbuf)
+          ! Safety check: ensure tag is non-empty
+          IF (LEN_TRIM(tag) == 0) THEN
+             ERROR STOP 'read_pp_pswfc: empty tag after construction'
+          END IF
        ELSE
           tag = 'pp_chi'
        END IF
        CALL xmlr_readtag( tag, upf%chi(1:upf%mesh,nw) )
+       ! Robust check: ensure array is non-empty
+       IF (SIZE(upf%chi(1:upf%mesh,nw)) == 0) THEN
+          ERROR STOP 'read_pp_pswfc: empty chi array'
+       END IF
        call get_attr('index', ind)
        ! not-so-strict test: index is absent or incorrect in some UPF v.2 files
        if ( .NOT. v2 .AND. ind /= nw ) then
@@ -574,6 +673,10 @@ CONTAINS
        end if
        call get_attr( 'label', upf%els(nw) )
        call get_attr( 'l', upf%lchi(nw) )
+       ! Robust check: ensure l is valid (0 <= l <= lmax)
+       IF (upf%lchi(nw) < 0 .OR. upf%lchi(nw) > upf%lmax) THEN
+          ERROR STOP 'read_pp_pswfc: invalid l'
+       END IF
        IF ( .not. v2 .and. upf%has_so ) call get_attr( 'jchi', upf%jchi(nw) )
        call get_attr( 'occupation', upf%oc(nw) )
        call get_attr( 'n', upf%nchi(nw) )
@@ -581,6 +684,7 @@ CONTAINS
        call get_attr( 'cutoff_radius', upf%rcut_chi(nw) )
        call get_attr( 'ultrasoft_cutoff_radius', upf%rcutus_chi(nw) )
     END DO
+    !
     CALL xmlr_closetag( ) ! end pp_pswfc
     !
   END SUBROUTINE read_pp_pswfc
@@ -595,15 +699,20 @@ CONTAINS
     !
     INTEGER :: nb, mb
     CHARACTER(LEN=15) :: tag
+    CHARACTER(LEN=64) :: tag_buf
+    CHARACTER(LEN=32) :: nbuf  ! For MinGW-safe tag construction
     !
     IF ( upf%has_wfc ) THEN
        !
        ALLOCATE (upf%aewfc(1:upf%mesh,upf%nbeta) )
-       CALL xmlr_opentag( capitalize_if_v2('pp_full_wfc') )
+       CALL capitalize_if_v2_into('pp_full_wfc', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
        !
        DO nb = 1, upf%nbeta
           IF ( v2 ) THEN
-             tag = 'PP_AEWFC.'//i2c(nb)
+             ! MinGW-safe tag construction
+             WRITE(nbuf,'(I0)') nb
+             tag = 'PP_AEWFC.' // TRIM(nbuf)
           ELSE
              tag = 'pp_aewfc'
           END IF
@@ -622,7 +731,9 @@ CONTAINS
           ALLOCATE (upf%paw%aewfc_rel(1:upf%mesh,upf%nbeta) )
           DO nb = 1, upf%nbeta
              IF ( v2 ) THEN
-                tag = 'PP_AEWFC_REL.'//i2c(nb)
+                ! MinGW-safe tag construction
+                WRITE(nbuf,'(I0)') nb
+                tag = 'PP_AEWFC_REL.' // TRIM(nbuf)
              ELSE
                 tag = 'pp_aewfc_rel'
              END IF
@@ -639,7 +750,9 @@ CONTAINS
        ALLOCATE (upf%pswfc(1:upf%mesh,upf%nbeta) )
        DO nb = 1, upf%nbeta
           IF ( v2 ) THEN
-             tag = 'PP_PSWFC.'//i2c(nb)
+             ! MinGW-safe tag construction
+             WRITE(nbuf,'(I0)') nb
+             tag = 'PP_PSWFC.' // TRIM(nbuf)
           ELSE
              tag = 'pp_pswfc'
           END IF
@@ -666,13 +779,17 @@ CONTAINS
     TYPE(pseudo_upf),INTENT(INOUT) :: upf ! the pseudo data
     INTEGER, INTENT(INOUT) :: ierr
     !
+    CHARACTER(LEN=64) :: tag_buf
+    !
     ierr = 0
     if ( .NOT. upf%with_metagga_info ) RETURN
     !
     allocate ( upf%tau_core(upf%mesh) )
     allocate ( upf%tau_atom(upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_taumod'), upf%tau_core(:) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_tauatom'), upf%tau_atom(:) )
+    CALL capitalize_if_v2_into('pp_taumod', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%tau_core(:) )
+    CALL capitalize_if_v2_into('pp_tauatom', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%tau_atom(:) )
     !
   END SUBROUTINE read_pp_metagga
   !
@@ -685,12 +802,15 @@ CONTAINS
     INTEGER, INTENT(INOUT) :: ierr
     INTEGER :: nw, nb, nn
     CHARACTER(LEN=1) :: dummy
+    CHARACTER(LEN=32) :: nbuf  ! For MinGW-safe tag construction
     !
     IF ( .NOT. v2 .OR. .NOT. upf%has_so ) RETURN
     !
     CALL xmlr_opentag( 'PP_SPIN_ORB' )
     DO nw = 1,upf%nwfc
-       CALL xmlr_readtag( 'PP_RELWFC.'//i2c(nw), dummy )
+       ! MinGW-safe tag construction
+       WRITE(nbuf,'(I0)') nw
+       CALL xmlr_readtag( 'PP_RELWFC.' // TRIM(nbuf), dummy )
        CALL get_attr( 'index' , nb )
        ! not-so-strict test: index absent or incorrect in some UPF v.2 files
        IF ( .NOT. v2 .AND. nb /= nw ) THEN
@@ -711,7 +831,9 @@ CONTAINS
     ENDDO
     !
     DO nb = 1,upf%nbeta
-       CALL xmlr_readtag( 'PP_RELBETA.'//i2c(nb), dummy, ierr )
+       ! MinGW-safe tag construction
+       WRITE(nbuf,'(I0)') nb
+       CALL xmlr_readtag( 'PP_RELBETA.' // TRIM(nbuf), dummy, ierr )
        !
        ! existing PP files may have pp_relbeta first, pp_relwfc later,
        ! but also the other way round
@@ -737,23 +859,28 @@ CONTAINS
     TYPE(pseudo_upf),INTENT(INOUT) :: upf ! the pseudo data
     INTEGER, INTENT(INOUT) :: ierr
     INTEGER :: nb, mb
+    CHARACTER(LEN=64) :: tag_buf
     !
     IF ( .NOT. upf%tpawp ) RETURN
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_paw') )
+    CALL capitalize_if_v2_into('pp_paw', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     CALL get_attr ('paw_data_format', upf%paw_data_format)
     CALL get_attr ('core_energy', upf%paw%core_energy) 
     ! Full occupation (not only > 0 ones)
     ALLOCATE (upf%paw%oc(upf%nbeta) )
     ALLOCATE (upf%paw%ae_rho_atc(upf%mesh) )
     ALLOCATE (upf%paw%ae_vloc(upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_occupations'), &
+    CALL capitalize_if_v2_into('pp_occupations', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%oc(1:upf%nbeta) )
     ! All-electron core charge
-    CALL xmlr_readtag( capitalize_if_v2('pp_ae_nlcc'), &
+    CALL capitalize_if_v2_into('pp_ae_nlcc', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%ae_rho_atc(1:upf%mesh) )
     ! All-electron local potential
-    CALL xmlr_readtag( capitalize_if_v2('pp_ae_vloc'), &
+    CALL capitalize_if_v2_into('pp_ae_vloc', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%ae_vloc(1:upf%mesh) )
     CALL xmlr_closetag () ! end pp_paw
     !
@@ -812,10 +939,13 @@ CONTAINS
     !
     INTEGER :: nb, mb
     CHARACTER(LEN=24) :: tag
+    CHARACTER(LEN=64) :: tag_buf
+    CHARACTER(LEN=32) :: nbuf  ! For MinGW-safe tag construction
     !
     IF (.NOT. upf%has_gipaw) RETURN
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_gipaw') )
+    CALL capitalize_if_v2_into('pp_gipaw', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     CALL get_attr ('gipaw_data_format', upf%gipaw_data_format ) 
     IF ( v2 ) THEN
        CALL xmlr_opentag( 'PP_GIPAW_CORE_ORBITALS', IERR=ierr )
@@ -833,7 +963,9 @@ CONTAINS
     ALLOCATE ( upf%gipaw_core_orbital_l(upf%gipaw_ncore_orbitals) )
     DO nb = 1,upf%gipaw_ncore_orbitals
        IF ( v2 ) THEN
-          tag = "PP_GIPAW_CORE_ORBITAL."//i2c(nb)
+          ! MinGW-safe tag construction
+          WRITE(nbuf,'(I0)') nb
+          tag = "PP_GIPAW_CORE_ORBITAL." // TRIM(nbuf)
        ELSE
           tag = 'pp_gipaw_core_orbital'
        END IF
@@ -896,7 +1028,9 @@ CONTAINS
        ALLOCATE ( upf%gipaw_wfs_ps(upf%mesh,upf%gipaw_wfs_nchannels) )
        DO nb = 1,upf%gipaw_wfs_nchannels
           IF ( v2 ) THEN
-             tag = "PP_GIPAW_ORBITAL."//i2c(nb)
+             ! MinGW-safe tag construction
+             WRITE(nbuf,'(I0)') nb
+             tag = "PP_GIPAW_ORBITAL." // TRIM(nbuf)
           ELSE
              tag = 'pp_gipaw_orbital'
           END IF
@@ -911,9 +1045,11 @@ CONTAINS
           CALL get_attr ('l',     upf%gipaw_wfs_ll(nb) )
           CALL get_attr ('cutoff_radius', upf%gipaw_wfs_rcut(nb) )
           CALL get_attr ('ultrasoft_cutoff_radius', upf%gipaw_wfs_rcutus(nb) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_wfs_ae'), &
+          CALL capitalize_if_v2_into('pp_gipaw_wfs_ae', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf), &
                upf%gipaw_wfs_ae(1:upf%mesh,nb) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_wfs_ps'),&
+          CALL capitalize_if_v2_into('pp_gipaw_wfs_ps', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf),&
                upf%gipaw_wfs_ps(1:upf%mesh,nb) )
           CALL xmlr_closetag ()
        END DO
@@ -923,10 +1059,13 @@ CONTAINS
        !
        ALLOCATE ( upf%gipaw_vlocal_ae(upf%mesh) )
        ALLOCATE ( upf%gipaw_vlocal_ps(upf%mesh) )
-       CALL xmlr_opentag( capitalize_if_v2('pp_gipaw_vlocal') )
-       CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_vlocal_ae'), &
+       CALL capitalize_if_v2_into('pp_gipaw_vlocal', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
+       CALL capitalize_if_v2_into('pp_gipaw_vlocal_ae', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), &
             upf%gipaw_vlocal_ae(1:upf%mesh) )
-       CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_vlocal_ps'), &
+       CALL capitalize_if_v2_into('pp_gipaw_vlocal_ps', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), &
             upf%gipaw_vlocal_ps(1:upf%mesh) )
        CALL xmlr_closetag ()
     END IF
diff --git a/upflib/write_upf_new.f90 b/upflib/write_upf_new.f90
index 546fa90..ba5200f 100644
--- a/upflib/write_upf_new.f90
+++ b/upflib/write_upf_new.f90
@@ -41,6 +41,7 @@ CONTAINS
     !!  generation input in the upf file
     !
     CHARACTER(LEN=5) :: schema_='qe_pp'
+    CHARACTER(LEN=64) :: tag_buf
     CHARACTER(LEN=*), PARAMETER   :: QE_PP_URI = &
          "http://www.quantum-espresso.org/ns/qes/qe_pp-1.0", &
          XSI = "http://www.w3.org/2001/XMLSchema-instance", &
@@ -102,11 +103,13 @@ CONTAINS
     !
     IF( upf%nlcc ) THEN
        CALL add_attr( 'size', upf%mesh )
-       CALL xmlw_writetag(capitalize_if_v2('pp_nlcc'), upf%rho_atc(1:upf%mesh))
+       CALL capitalize_if_v2_into('pp_nlcc', v2, tag_buf)
+       CALL xmlw_writetag(TRIM(tag_buf), upf%rho_atc(1:upf%mesh))
     END IF
     IF( .NOT. upf%tcoulombp ) THEN
        CALL add_attr( 'size', upf%mesh )
-       CALL xmlw_writetag( capitalize_if_v2('pp_local'), upf%vloc(1:upf%mesh))
+       CALL capitalize_if_v2_into('pp_local', v2, tag_buf)
+       CALL xmlw_writetag( TRIM(tag_buf), upf%vloc(1:upf%mesh))
     END IF
     !
     CALL write_pp_semilocal ( upf )
@@ -118,7 +121,8 @@ CONTAINS
     CALL write_pp_full_wfc ( upf )
     !
     CALL add_attr( 'size', upf%mesh )
-    CALL xmlw_writetag( capitalize_if_v2('pp_rhoatom'), upf%rho_at(1:upf%mesh))
+    CALL capitalize_if_v2_into('pp_rhoatom', v2, tag_buf)
+    CALL xmlw_writetag( TRIM(tag_buf), upf%rho_at(1:upf%mesh))
     !
     CALL write_pp_metagga ( upf )
     !
@@ -138,28 +142,56 @@ CONTAINS
     !
   END SUBROUTINE write_upf
   !
-  FUNCTION capitalize_if_v2 ( strin ) RESULT ( strout )
+  SUBROUTINE capitalize_if_v2_into ( strin, v2_flag, strout )
     !
-    ! returns a capitalized string for UPF v.2, the same string otherwise
+    ! Robust MinGW-safe version: writes capitalized string for UPF v.2, 
+    ! same string otherwise, into fixed-length output buffer.
     ! (UPF v.2 uses capitalized tags, UPF with schema use lowercase)
     !
+    ! This subroutine avoids allocatable CHARACTER returns that cause
+    ! empty-tag bugs on MinGW gfortran.
+    !
     USE upf_utils, ONLY: capital
     IMPLICIT NONE
-    CHARACTER(LEN=*) :: strin
+    CHARACTER(LEN=*), INTENT(IN)  :: strin
+    LOGICAL,          INTENT(IN)  :: v2_flag
+    CHARACTER(LEN=*), INTENT(OUT) :: strout
     !
-    INTEGER :: n
-    CHARACTER(LEN=:), ALLOCATABLE :: strout
+    INTEGER :: n, lt, lout
     !
-    IF ( v2 ) THEN
-       strout = ''
-       DO n = 1,LEN_TRIM(strin)
-          strout = strout // capital(strin(n:n))
+    ! Initialize output to empty
+    strout = ''
+    !
+    ! Get trimmed input length
+    lt = LEN_TRIM(strin)
+    lout = LEN(strout)
+    !
+    ! Guard: detect empty input
+    IF (lt == 0) THEN
+       RETURN
+    END IF
+    !
+    ! Guard: ensure output buffer is large enough
+    IF (lout < lt) THEN
+       WRITE(*,'("FATAL: capitalize_if_v2_into: output buffer too small")')
+       WRITE(*,'("  Input length: ",I0,", buffer size: ",I0)') lt, lout
+       ERROR STOP 'capitalize_if_v2_into: buffer overflow'
+    END IF
+    !
+    IF ( v2_flag ) THEN
+       ! UPF v.2: capitalize each character
+       ! Use direct character assignment (NO concatenation)
+       DO n = 1, lt
+          strout(n:n) = capital(strin(n:n))
        END DO
+       ! Pad remainder with blanks (already done by initialization)
     ELSE
-       strout = TRIM(strin)
+       ! UPF schema: copy trimmed input
+       strout(1:lt) = strin(1:lt)
+       ! Remainder already blank from initialization
     END IF
     !
-  END FUNCTION capitalize_if_v2
+  END SUBROUTINE capitalize_if_v2_into
   !
   !--------------------------------------------------------
   SUBROUTINE write_pp_info_schema ( upf, conf, u_input )
@@ -439,18 +471,23 @@ CONTAINS
     IMPLICIT NONE
     TYPE(pseudo_upf),INTENT(IN) :: upf ! the pseudo data
     !
+    CHARACTER(LEN=64) :: tag_buf
     IF ( upf%dx > 0.d0) THEN
        CALL add_attr( 'mesh', upf%mesh )
        CALL add_attr( 'dx', upf%dx )
        CALL add_attr( 'xmin', upf%xmin )
        CALL add_attr( 'rmax', upf%rmax )
        CALL add_attr( 'zmesh', upf%zmesh )
-       CALL xmlw_opentag( capitalize_if_v2('pp_mesh') )
+       CALL capitalize_if_v2_into('pp_mesh', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
     ELSE
-       CALL xmlw_opentag( capitalize_if_v2('pp_mesh') )
+       CALL capitalize_if_v2_into('pp_mesh', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
     END IF
-    CALL xmlw_writetag( capitalize_if_v2('pp_r'), upf%r(1:upf%mesh) )
-    CALL xmlw_writetag( capitalize_if_v2('pp_rab'), upf%rab(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_r', v2, tag_buf)
+    CALL xmlw_writetag( TRIM(tag_buf), upf%r(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_rab', v2, tag_buf)
+    CALL xmlw_writetag( TRIM(tag_buf), upf%rab(1:upf%mesh) )
     !
     CALL xmlw_closetag( ) ! end pp_mesh
     !
@@ -465,9 +502,11 @@ CONTAINS
     !
     INTEGER :: nb, ind, l
     CHARACTER(LEN=8) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     !
     IF ( upf%typ == "SL" ) THEN
-       CALL xmlw_opentag( capitalize_if_v2('pp_semilocal') )
+       CALL capitalize_if_v2_into('pp_semilocal', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        !
        DO nb = 1,upf%nbeta
           l = upf%lll(nb)
@@ -503,8 +542,10 @@ CONTAINS
     LOGICAL :: isnull
     INTEGER :: nb, ind, l, ln, lm, mb, nmb
     CHARACTER(LEN=15) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     !
-    CALL xmlw_opentag( capitalize_if_v2('pp_nonlocal') )
+    CALL capitalize_if_v2_into('pp_nonlocal', v2, tag_buf)
+    CALL xmlw_opentag( TRIM(tag_buf) )
     !
     DO nb = 1,upf%nbeta
        !
@@ -531,7 +572,8 @@ CONTAINS
     !
     call add_attr( 'columns',  upf%nbeta )
     call add_attr( 'rows', upf%nbeta )
-    CALL xmlw_opentag( capitalize_if_v2 ('pp_dij') )
+    CALL capitalize_if_v2_into('pp_dij', v2, tag_buf)
+    CALL xmlw_opentag( TRIM(tag_buf) )
     DO nb = 1,upf%nbeta
        WRITE(iun,*) upf%dion(1:upf%nbeta,nb)
     END DO
@@ -552,7 +594,8 @@ CONTAINS
              CALL add_attr( 'l_max_aug', upf%paw%lmax_aug )
           ENDIF
        END IF
-       CALL xmlw_opentag( capitalize_if_v2('pp_augmentation') )
+       CALL capitalize_if_v2_into('pp_augmentation', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        !
        IF ( .NOT. v2 ) THEN
           CALL xmlw_writetag( 'q_with_l', upf%q_with_l )
@@ -569,7 +612,8 @@ CONTAINS
        !
        nb = upf%nbeta*upf%nbeta
        call add_attr( 'size', nb )
-       CALL xmlw_opentag( capitalize_if_v2('pp_q') )
+       CALL capitalize_if_v2_into('pp_q', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        DO nb = 1,upf%nbeta
           WRITE(iun,*) upf%qqq(1:upf%nbeta,nb)
        END DO
@@ -580,7 +624,8 @@ CONTAINS
                &      'multipole array dims = (nbeta,nbeta,2*lmax+1)-->')")
           call add_attr( 'nbeta', upf%nbeta )
           call add_attr( 'lmax', upf%lmax )
-          CALL xmlw_opentag( capitalize_if_v2('pp_multipoles') )
+          CALL capitalize_if_v2_into('pp_multipoles', v2, tag_buf)
+          CALL xmlw_opentag( TRIM(tag_buf) )
           DO l = 0,2*upf%lmax
              DO nb = 1,upf%nbeta
                 WRITE(iun,*) upf%paw%augmom(1:upf%nbeta,nb,l)
@@ -663,8 +708,10 @@ CONTAINS
     !
     INTEGER :: nw, ind, l
     CHARACTER(LEN=8) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     !
-    CALL xmlw_opentag( capitalize_if_v2('pp_pswfc') )
+    CALL capitalize_if_v2_into('pp_pswfc', v2, tag_buf)
+    CALL xmlw_opentag( TRIM(tag_buf) )
     DO nw =1, upf%nwfc
        call add_attr( 'size', upf%mesh )
        call add_attr( 'index', nw )
@@ -703,11 +750,13 @@ CONTAINS
     !
     INTEGER :: nb
     CHARACTER(LEN=15) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     !
     IF ( upf%has_wfc ) THEN
        !
        call add_attr( 'number_of_wfc', upf%nbeta )
-       CALL xmlw_opentag( capitalize_if_v2('pp_full_wfc') )
+       CALL capitalize_if_v2_into('pp_full_wfc', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        !
        DO nb = 1, upf%nbeta
           IF ( v2 ) THEN
@@ -761,10 +810,14 @@ CONTAINS
     IMPLICIT NONE
     TYPE(pseudo_upf),INTENT(IN) :: upf ! the pseudo data
     !
+    CHARACTER(LEN=64) :: tag_buf
+    !
     if ( .NOT. upf%with_metagga_info ) RETURN
     !
-    CALL xmlw_writetag( capitalize_if_v2('pp_taumod'), upf%tau_core(:) )
-    CALL xmlw_writetag( capitalize_if_v2('pp_tauatom'), upf%tau_atom(:) )
+    CALL capitalize_if_v2_into('pp_taumod', v2, tag_buf)
+    CALL xmlw_writetag( TRIM(tag_buf), upf%tau_core(:) )
+    CALL capitalize_if_v2_into('pp_tauatom', v2, tag_buf)
+    CALL xmlw_writetag( TRIM(tag_buf), upf%tau_atom(:) )
     !
   END SUBROUTINE write_pp_metagga
   !
@@ -806,21 +859,27 @@ CONTAINS
     IMPLICIT NONE
     TYPE(pseudo_upf),INTENT(IN) :: upf ! the pseudo data
     !
+    CHARACTER(LEN=64) :: tag_buf
+    !
     IF ( upf%tpawp ) THEN
        call add_attr( 'paw_data_format', upf%paw_data_format )
        call add_attr( 'core_energy', upf%paw%core_energy )
-       CALL xmlw_opentag( capitalize_if_v2('pp_paw') )
+       CALL capitalize_if_v2_into('pp_paw', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        ! Full occupation (not only > 0 ones)
        call add_attr( 'size', upf%nbeta )
-       CALL xmlw_writetag( capitalize_if_v2('pp_occupations'), &
+       CALL capitalize_if_v2_into('pp_occupations', v2, tag_buf)
+       CALL xmlw_writetag( TRIM(tag_buf), &
             upf%paw%oc(1:upf%nbeta) )
        ! All-electron core charge
        call add_attr( 'size', upf%mesh )
-       CALL xmlw_writetag( capitalize_if_v2('pp_ae_nlcc'), &
+       CALL capitalize_if_v2_into('pp_ae_nlcc', v2, tag_buf)
+       CALL xmlw_writetag( TRIM(tag_buf), &
             upf%paw%ae_rho_atc(1:upf%mesh) )
        ! All-electron local potential
        call add_attr( 'size', upf%mesh )
-       CALL xmlw_writetag( capitalize_if_v2('pp_ae_vloc'), &
+       CALL capitalize_if_v2_into('pp_ae_vloc', v2, tag_buf)
+       CALL xmlw_writetag( TRIM(tag_buf), &
             upf%paw%ae_vloc(1:upf%mesh) )
        CALL xmlw_closetag () ! end pp_paw
     END IF
@@ -835,10 +894,12 @@ CONTAINS
     !
     INTEGER :: nb
     CHARACTER(LEN=24) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     !
     IF (upf%has_gipaw) THEN
        call add_attr( 'gipaw_data_format', upf%gipaw_data_format )
-       CALL xmlw_opentag( capitalize_if_v2('pp_gipaw') )
+       CALL capitalize_if_v2_into('pp_gipaw', v2, tag_buf)
+       CALL xmlw_opentag( TRIM(tag_buf) )
        IF ( v2 ) THEN
           call add_attr( 'number_of_core_orbitals', upf%gipaw_ncore_orbitals )
           CALL xmlw_opentag( 'PP_GIPAW_CORE_ORBITALS' )
@@ -886,22 +947,27 @@ CONTAINS
              CALL xmlw_opentag( tag)
              !
              call add_attr( 'size', upf%mesh )
-             CALL xmlw_writetag( capitalize_if_v2('pp_gipaw_wfs_ae'), &
+             CALL capitalize_if_v2_into('pp_gipaw_wfs_ae', v2, tag_buf)
+             CALL xmlw_writetag( TRIM(tag_buf), &
                   upf%gipaw_wfs_ae(1:upf%mesh,nb) )
              call add_attr( 'size', upf%mesh )
-             CALL xmlw_writetag( capitalize_if_v2('pp_gipaw_wfs_ps'),&
+             CALL capitalize_if_v2_into('pp_gipaw_wfs_ps', v2, tag_buf)
+             CALL xmlw_writetag( TRIM(tag_buf),&
                   upf%gipaw_wfs_ps(1:upf%mesh,nb) )
              CALL xmlw_closetag ()
           END DO
           IF ( v2 ) CALL xmlw_closetag( )
           !
           ! Write all-electron and pseudo local potentials
-          CALL xmlw_opentag( capitalize_if_v2('pp_gipaw_vlocal') )
+          CALL capitalize_if_v2_into('pp_gipaw_vlocal', v2, tag_buf)
+          CALL xmlw_opentag( TRIM(tag_buf) )
           call add_attr( 'size', upf%mesh )
-          CALL xmlw_writetag( capitalize_if_v2('pp_gipaw_vlocal_ae'), &
+          CALL capitalize_if_v2_into('pp_gipaw_vlocal_ae', v2, tag_buf)
+          CALL xmlw_writetag( TRIM(tag_buf), &
                upf%gipaw_vlocal_ae(1:upf%mesh) )
           call add_attr( 'size', upf%mesh )
-          CALL xmlw_writetag( capitalize_if_v2('pp_gipaw_vlocal_ps'), &
+          CALL capitalize_if_v2_into('pp_gipaw_vlocal_ps', v2, tag_buf)
+          CALL xmlw_writetag( TRIM(tag_buf), &
                upf%gipaw_vlocal_ps(1:upf%mesh) )
           CALL xmlw_closetag ()
        END IF
