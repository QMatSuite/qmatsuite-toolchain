--- a/upflib/read_upf_new.f90
+++ b/upflib/read_upf_new.f90
@@ -149,19 +149,40 @@
     !
   END SUBROUTINE read_upf_new
   !
-  FUNCTION capitalize_if_v2 ( strin ) RESULT ( strout )
+  SUBROUTINE capitalize_if_v2_into ( strin, v2_flag, strout )
     !
-    ! returns a capitalized string for UPF v.2, the same string otherwise
-    ! (UPF v.2 uses capitalized tags, UPF with schema use lowercase)
+    ! Robust MinGW-safe version: writes capitalized string for UPF v.2, 
+    ! same string otherwise, into fixed-length output buffer.
+    ! (UPF v.2 uses capitalized tags, UPF with schema use lowercase)
+    !
+    ! This subroutine avoids allocatable CHARACTER returns that cause
+    ! empty-tag bugs on MinGW gfortran.
     !
     USE upf_utils, ONLY: capital
     IMPLICIT NONE
-    CHARACTER(LEN=*) :: strin
+    CHARACTER(LEN=*), INTENT(IN)  :: strin
+    LOGICAL,          INTENT(IN)  :: v2_flag
+    CHARACTER(LEN=*), INTENT(OUT) :: strout
     !
-    INTEGER :: n
-    CHARACTER(LEN=:), ALLOCATABLE :: strout
+    INTEGER :: n, lt, lout
     !
-    ! Guard: detect empty input (would cause empty tag bug)
-    IF (LEN_TRIM(strin) == 0) THEN
+    ! Initialize output to empty
+    strout = ''
+    !
+    ! Get trimmed input length
+    lt = LEN_TRIM(strin)
+    lout = LEN(strout)
+    !
+    ! Guard: detect empty input
+    IF (lt == 0) THEN
        WRITE(stdout,'("FATAL: capitalize_if_v2 called with empty string")')
-       strout = ''  ! Return empty but caller should check
        RETURN
     END IF
     !
-    IF ( v2 ) THEN
-       ! Fix for MinGW gfortran: explicitly allocate and build capitalized string
-       ! Avoid potential issues with allocatable character concatenation in loop
-       ALLOCATE(CHARACTER(LEN=lt) :: strout)
-       DO n = 1, lt
-          strout(n:n) = capital(strin(n:n))
-       END DO
-    ELSE
-       strout = TRIM(strin)
+    ! Guard: ensure output buffer is large enough
+    IF (lout < lt) THEN
+       WRITE(stdout,'("FATAL: capitalize_if_v2_into: output buffer too small")')
+       WRITE(stdout,'("  Input length: ",I0,", buffer size: ",I0)') lt, lout
+       ERROR STOP 'capitalize_if_v2_into: buffer overflow'
     END IF
     !
-    ! Final safety check: ensure result is non-empty (should never fail for non-empty input)
-    IF (LEN_TRIM(strout) == 0 .AND. lt > 0) THEN
-       WRITE(stdout,'("FATAL: capitalize_if_v2 produced empty string from non-empty input")')
-       WRITE(stdout,'("  Input: [",A,"], v2=",L1)') strin, v2
-       ! Fallback: return original string to prevent crash
-       strout = TRIM(strin)
+    IF ( v2_flag ) THEN
+       ! UPF v.2: capitalize each character
+       ! Use direct character assignment (NO concatenation)
+       DO n = 1, lt
+          strout(n:n) = capital(strin(n:n))
+       END DO
+       ! Pad remainder with blanks (already done by initialization)
+    ELSE
+       ! UPF schema: copy trimmed input
+       strout(1:lt) = strin(1:lt)
+       ! Remainder already blank from initialization
     END IF
     !
-  END FUNCTION capitalize_if_v2
+    ! Final safety check: ensure result is non-empty
+    IF (LEN_TRIM(strout) == 0 .AND. lt > 0) THEN
+       WRITE(stdout,'("FATAL: capitalize_if_v2_into produced empty string from non-empty input")')
+       WRITE(stdout,'("  Input: [",A,"], v2_flag=",L1,", lt=",I0)') strin, v2_flag, lt
+       ERROR STOP 'capitalize_if_v2_into: empty result'
+    END IF
+    !
+  END SUBROUTINE capitalize_if_v2_into
   !--------------------------------------------------------
   SUBROUTINE read_pp_header_schema ( upf )
     !--------------------------------------------------------
@@ -219,9 +240,12 @@
     IMPLICIT NONE
     TYPE(pseudo_upf), INTENT(INOUT) :: upf ! the pseudo data
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_header') )
+    CHARACTER(LEN=64) :: tag_buf
     !
+    CALL capitalize_if_v2_into('pp_header', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     !
     CALL xmlr_readtag( 'element', upf%psd )
     CALL xmlr_readtag( 'z_valence', upf%zp )
@@ -233,9 +257,12 @@
     IMPLICIT NONE
     TYPE(pseudo_upf), INTENT(INOUT) :: upf ! the pseudo data
     !
-    CHARACTER(LEN=1) :: dummy
+    CHARACTER(LEN=1) :: dummy
+    CHARACTER(LEN=64) :: tag_buf
     !
-    CALL xmlr_readtag ( capitalize_if_v2('pp_header'), dummy )
+    ! Robust MinGW-safe tag handling: use fixed-length buffer
+    CALL capitalize_if_v2_into('pp_header', v2, tag_buf)
+    CALL xmlr_readtag ( TRIM(tag_buf), dummy )
     CALL get_attr ('generated', upf%generated)
     CALL get_attr ('author', upf%author)
     CALL get_attr ('date', upf%date)
@@ -263,6 +290,7 @@
     TYPE(pseudo_upf),INTENT(INOUT) :: upf ! the pseudo data
     integer :: mesh
     !
+    CHARACTER(LEN=64) :: tag_buf
     CALL xmlr_opentag( capitalize_if_v2('pp_mesh') )
     CALL get_attr ( 'mesh', mesh )
     if ( mesh == 0 ) THEN
@@ -275,8 +303,10 @@
     CALL get_attr ( 'xmin', upf%xmin )
     CALL get_attr ( 'rmax', upf%rmax )
     CALL get_attr ( 'zmesh', upf%zmesh )
     allocate ( upf%r(1:upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_r'), upf%r(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_r', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%r(1:upf%mesh) )
     allocate ( upf%rab(1:upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_rab'), upf%rab(1:upf%mesh) )
+    CALL capitalize_if_v2_into('pp_rab', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%rab(1:upf%mesh) )
     !
     CALL xmlr_closetag( ) ! end pp_mesh
     !
@@ -290,6 +320,7 @@
     INTEGER :: nb, ind, l, j
     CHARACTER(LEN=9) :: tag
     real(dp), allocatable :: vnl(:)
     !
+    CHARACTER(LEN=64) :: tag_buf
     IF ( upf%typ == "SL" ) THEN
        !
        IF ( upf%has_so ) then
@@ -298,7 +329,8 @@
           ALLOCATE(upf%vnl(upf%mesh,0:upf%lmax,1))
        end if
        allocate ( vnl(1:upf%mesh) )
-       CALL xmlr_opentag( capitalize_if_v2('pp_semilocal') )       
+       CALL capitalize_if_v2_into('pp_semilocal', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
        !
        tag = 'vnl'
        DO nb = 1,upf%nbeta
@@ -340,6 +372,7 @@
     LOGICAL :: isnull
     INTEGER :: nb, ind, l, l_, ln, lm, mb, nmb
     CHARACTER(LEN=15) :: tag
+    CHARACTER(LEN=64) :: tag_buf
     REAL(dp), ALLOCATABLE :: aux(:)
     !
     nb = upf%nbeta
@@ -358,7 +391,8 @@
        RETURN
     END IF
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_nonlocal') )
+    CALL capitalize_if_v2_into('pp_nonlocal', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     !
     DO nb = 1,upf%nbeta
        !
@@ -385,7 +419,8 @@
     !
     ! pp_dij (D_lm matrix)
     !
-    CALL xmlr_readtag ( capitalize_if_v2 ('pp_dij'), upf%dion )
+    CALL capitalize_if_v2_into('pp_dij', v2, tag_buf)
+    CALL xmlr_readtag ( TRIM(tag_buf), upf%dion )
     !
     ! pp_augmentation
     !
     IF (upf%tvanp .or. upf%tpawp) THEN
-       CALL xmlr_opentag( capitalize_if_v2('pp_augmentation') )
+       CALL capitalize_if_v2_into('pp_augmentation', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
        !
        IF ( v2 ) THEN
           CALL get_attr ( 'q_with_l', upf%q_with_l )
@@ -415,7 +450,8 @@
           ENDIF
        ENDIF
        !
-       CALL xmlr_readtag( capitalize_if_v2('pp_q'), upf%qqq )
+       CALL capitalize_if_v2_into('pp_q', v2, tag_buf)
+       CALL xmlr_readtag( TRIM(tag_buf), upf%qqq )
        !
        IF ( upf%tpawp ) THEN
           ALLOCATE ( upf%paw%augmom(1:upf%nbeta,1:upf%nbeta,0:2*upf%lmax) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_multipoles'), upf%paw%augmom )
+          CALL capitalize_if_v2_into('pp_multipoles', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf), upf%paw%augmom )
        ENDIF
        !
        ! read polinomial coefficients for Q_ij expansion at small radius
@@ -550,6 +586,7 @@
     INTEGER :: nw, ind, l
     CHARACTER(LEN=9) :: tag
     !
+    CHARACTER(LEN=64) :: tag_buf
     allocate ( upf%chi(1:upf%mesh,upf%nwfc) )
     allocate ( upf%els(upf%nwfc), &
                 upf%oc(upf%nwfc), &
@@ -560,7 +597,8 @@
                 upf%epseu(upf%nwfc) )
     IF ( upf%has_so ) allocate ( upf%jchi(upf%nwfc) )
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_pswfc') )
+    CALL capitalize_if_v2_into('pp_pswfc', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     DO nw=1,upf%nwfc
        IF ( v2 ) THEN
           tag = 'PP_CHI.'//i2c(nw)
@@ -600,6 +638,7 @@
     INTEGER :: nb, mb
     CHARACTER(LEN=15) :: tag
     !
+    CHARACTER(LEN=64) :: tag_buf
     IF ( upf%has_wfc ) THEN
        !
        ALLOCATE (upf%aewfc(1:upf%mesh,upf%nbeta) )
-       CALL xmlr_opentag( capitalize_if_v2('pp_full_wfc') )
+       CALL capitalize_if_v2_into('pp_full_wfc', v2, tag_buf)
+       CALL xmlr_opentag( TRIM(tag_buf) )
        !
        DO nb = 1, upf%nbeta
@@ -670,6 +709,7 @@
     INTEGER, INTENT(INOUT) :: ierr
     !
     ierr = 0
+    CHARACTER(LEN=64) :: tag_buf
     if ( .NOT. upf%with_metagga_info ) RETURN
     !
     allocate ( upf%tau_core(upf%mesh) )
     allocate ( upf%tau_atom(upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_taumod'), upf%tau_core(:) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_tauatom'), upf%tau_atom(:) )
+    CALL capitalize_if_v2_into('pp_taumod', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%tau_core(:) )
+    CALL capitalize_if_v2_into('pp_tauatom', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), upf%tau_atom(:) )
     !
   END SUBROUTINE read_pp_metagga
   !
@@ -720,6 +760,7 @@
     IF ( .NOT. upf%tpawp ) RETURN
     !
+    CHARACTER(LEN=64) :: tag_buf
     CALL xmlr_opentag( capitalize_if_v2('pp_paw') )
     CALL get_attr ('paw_data_format', upf%paw_data_format)
     CALL get_attr ('core_energy', upf%paw%core_energy) 
     ! Full occupation (not only > 0 ones)
     ALLOCATE (upf%paw%oc(upf%nbeta) )
     ALLOCATE (upf%paw%ae_rho_atc(upf%mesh) )
     ALLOCATE (upf%paw%ae_vloc(upf%mesh) )
-    CALL xmlr_readtag( capitalize_if_v2('pp_occupations'), &
+    CALL capitalize_if_v2_into('pp_occupations', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%oc(1:upf%nbeta) )
     ! All-electron core charge
-    CALL xmlr_readtag( capitalize_if_v2('pp_ae_nlcc'), &
+    CALL capitalize_if_v2_into('pp_ae_nlcc', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%ae_rho_atc(1:upf%mesh) )
     ! All-electron local potential
-    CALL xmlr_readtag( capitalize_if_v2('pp_ae_vloc'), &
+    CALL capitalize_if_v2_into('pp_ae_vloc', v2, tag_buf)
+    CALL xmlr_readtag( TRIM(tag_buf), &
          upf%paw%ae_vloc(1:upf%mesh) )
     CALL xmlr_closetag () ! end pp_paw
     !
@@ -810,6 +851,7 @@
     INTEGER :: nb, mb
     CHARACTER(LEN=24) :: tag
     !
+    CHARACTER(LEN=64) :: tag_buf
     IF (.NOT. upf%has_gipaw) RETURN
     !
-    CALL xmlr_opentag( capitalize_if_v2('pp_gipaw') )
+    CALL capitalize_if_v2_into('pp_gipaw', v2, tag_buf)
+    CALL xmlr_opentag( TRIM(tag_buf) )
     CALL get_attr ('gipaw_data_format', upf%gipaw_data_format ) 
     IF ( v2 ) THEN
@@ -920,7 +962,9 @@
           CALL get_attr ('cutoff_radius', upf%gipaw_wfs_rcut(nb) )
           CALL get_attr ('ultrasoft_cutoff_radius', upf%gipaw_wfs_rcutus(nb) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_wfs_ae'), &
+          CALL capitalize_if_v2_into('pp_gipaw_wfs_ae', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf), &
               upf%gipaw_wfs_ae(1:upf%mesh,nb) )
-          CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_wfs_ps'),&
+          CALL capitalize_if_v2_into('pp_gipaw_wfs_ps', v2, tag_buf)
+          CALL xmlr_readtag( TRIM(tag_buf),&
               upf%gipaw_wfs_ps(1:upf%mesh,nb) )
           CALL xmlr_closetag ()
@@ -930,7 +974,10 @@
       ALLOCATE ( upf%gipaw_vlocal_ae(upf%mesh) )
       ALLOCATE ( upf%gipaw_vlocal_ps(upf%mesh) )
-      CALL xmlr_opentag( capitalize_if_v2('pp_gipaw_vlocal') )
-      CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_vlocal_ae'), &
+      CALL capitalize_if_v2_into('pp_gipaw_vlocal', v2, tag_buf)
+      CALL xmlr_opentag( TRIM(tag_buf) )
+      CALL capitalize_if_v2_into('pp_gipaw_vlocal_ae', v2, tag_buf)
+      CALL xmlr_readtag( TRIM(tag_buf), &
            upf%gipaw_vlocal_ae(1:upf%mesh) )
-      CALL xmlr_readtag( capitalize_if_v2('pp_gipaw_vlocal_ps'), &
+      CALL capitalize_if_v2_into('pp_gipaw_vlocal_ps', v2, tag_buf)
+      CALL xmlr_readtag( TRIM(tag_buf), &
           upf%gipaw_vlocal_ps(1:upf%mesh) )
       CALL xmlr_closetag ()
     END IF
@@ -938,6 +985,7 @@
     !
   END SUBROUTINE read_pp_gipaw
   !
+  ! Note: Also update read_upf_new subroutine to add tag_buf variable
+  ! and update all capitalize_if_v2 calls there (pp_nlcc, pp_local, pp_rhoatom)

