name: QE Windows oneAPI

on:
  push:
    paths:
      - 'toolchains/quantum_espresso/windows/oneapi/**'
      - '.github/workflows/qe-windows-oneapi-mkl.yml'
  pull_request:
    paths:
      - 'toolchains/quantum_espresso/windows/oneapi/**'
      - '.github/workflows/qe-windows-oneapi-mkl.yml'
  workflow_dispatch:

concurrency:
  group: windows-oneapi-qe-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: pwsh

jobs:
  build:
    # NOTE: Installs Intel oneAPI (compilers + MKL) and wires MKLROOT/CMAKE_PREFIX_PATH
    # so CMake FindLAPACK can locate MKL.
    runs-on: windows-latest
    env:
      ONEAPI_ROOT: 'C:\Program Files (x86)\Intel\oneAPI'
      QE_ROOT: '${{ github.workspace }}\toolchains\quantum_espresso\windows\oneapi'
      QE_SRC: '${{ github.workspace }}\toolchains\quantum_espresso\windows\oneapi\upstream\qe'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Cache QE source/build
        uses: actions/cache@v4
        with:
          path: |
            toolchains/quantum_espresso/windows/oneapi/upstream/qe
          key: qe-oneapi-${{ runner.os }}-${{ hashFiles('toolchains/quantum_espresso/windows/oneapi/patches/**', 'toolchains/quantum_espresso/windows/oneapi/scripts/**') }}
          restore-keys: |
            qe-oneapi-${{ runner.os }}-

      - name: Cache oneAPI installer
        id: cache-installer
        uses: actions/cache@v4
        with:
          path: |
            .github/cache/oneapi-installer
          key: oneapi-installer-2025.3.0-${{ runner.os }}
          restore-keys: |
            oneapi-installer-${{ runner.os }}-

      - name: Cache oneAPI installation
        id: cache-oneapi-install
        uses: actions/cache@v4
        with:
          path: |
            C:\Program Files (x86)\Intel\oneAPI\compiler
            C:\Program Files (x86)\Intel\oneAPI\mkl
            C:\Program Files (x86)\Intel\oneAPI\setvars.bat
            C:\Program Files (x86)\Intel\oneAPI\setvars-vcvarsall.bat
          key: oneapi-install-2025.3.0-${{ runner.os }}-cpp-dpcpp-common-ifort-compiler-mkl-devel
          restore-keys: |
            oneapi-install-2025.3.0-${{ runner.os }}-
            oneapi-install-${{ runner.os }}-

      - name: Verify cached oneAPI installation
        if: steps.cache-oneapi-install.outputs.cache-hit == 'true'
        run: |
          Write-Host "oneAPI installation restored from cache"
          if (-not (Test-Path "$env:ONEAPI_ROOT\setvars.bat")) {
            Write-Error "Cached oneAPI installation incomplete: setvars.bat not found"
            exit 1
          }
          Write-Host "Verified: oneAPI installation is complete"

      - name: Install oneAPI (compilers + MKL) via offline installer
        if: steps.cache-oneapi-install.outputs.cache-hit != 'true'
        # Install Intel oneAPI HPC Kit with compilers (ifx/icx) and MKL in one go.
        # Based on oneapi-ci approach: extract installer, then use bootstrapper with config file.
        # This avoids the slow/stuck installer issue when using --components flag directly on Windows.
        # Reference: https://community.intel.com/t5/Intel-oneAPI-Math-Kernel-Library/Installing-and-setting-up-oneAPI-base-kit-on-GitHub-Actions-and/m-p/1376598
        # HPC Kit 2025.3.0 URL - component IDs from https://oneapi-src.github.io/oneapi-ci/
        run: |
          $url = "https://registrationcenter-download.intel.com/akdlm/IRC_NAS/3a871580-f839-46ed-aeae-685084127279/intel-oneapi-hpc-toolkit-2025.3.0.378_offline.exe"
          $cacheDir = ".github/cache/oneapi-installer"
          $cachedInstaller = Join-Path $cacheDir "intel-oneapi-hpc-toolkit-2025.3.0.378_offline.exe"
          $installerExe = Join-Path $env:RUNNER_TEMP "oneapi_hpc_installer.exe"
          $extractDir = Join-Path $env:RUNNER_TEMP "oneapi_extracted"
          $configFile = Join-Path $env:RUNNER_TEMP "oneapi_install_config.ini"
          
          # Use cached installer if available, otherwise download
          if (Test-Path $cachedInstaller) {
            Write-Host "Using cached oneAPI installer from $cachedInstaller"
            Copy-Item -Path $cachedInstaller -Destination $installerExe -Force
          } else {
            Write-Host "Downloading oneAPI HPC Kit installer from $url"
            New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
            Invoke-WebRequest -Uri $url -OutFile $installerExe
            # Save to cache for next run
            Copy-Item -Path $installerExe -Destination $cachedInstaller -Force
            Write-Host "Cached installer for future runs"
          }
          
          Write-Host "Extracting installer to $extractDir"
          New-Item -ItemType Directory -Path $extractDir -Force | Out-Null
          $extractLog = Join-Path $env:RUNNER_TEMP "extract.log"
          
          # Use Start-Process to properly wait for extraction and capture exit code
          $extractProc = Start-Process -FilePath $installerExe -ArgumentList "-s", "-x", "-f", $extractDir, "--log", $extractLog -Wait -PassThru -NoNewWindow
          if ($extractProc.ExitCode -ne 0) {
            Write-Host "Extraction log contents:"
            if (Test-Path $extractLog) {
              Get-Content $extractLog -Tail 50
            }
            Write-Error "Extraction failed with exit code $($extractProc.ExitCode)"
            exit 1
          }
          
          Write-Host "Extraction completed successfully"
          
          Write-Host "Creating install config file for compilers + MKL"
          # Component IDs from https://oneapi-src.github.io/oneapi-ci/
          # intel.oneapi.win.cpp-dpcpp-common: C++ compiler (icx)
          # intel.oneapi.win.ifort-compiler: Fortran compiler (ifx/ifort)
          # intel.oneapi.win.mkl.devel: MKL development package
          $configContent = @(
            "eula=accept",
            "components=intel.oneapi.win.cpp-dpcpp-common:intel.oneapi.win.ifort-compiler:intel.oneapi.win.mkl.devel",
            'p="NEED_VS2017_INTEGRATION=0 NEED_VS2019_INTEGRATION=0 NEED_VS2022_INTEGRATION=0"'
          )
          $configContent | Out-File -FilePath $configFile -Encoding ASCII
          
          $bootstrapper = Join-Path $extractDir "bootstrapper.exe"
          if (-not (Test-Path $bootstrapper)) {
            Write-Error "Bootstrapper not found at $bootstrapper"
            exit 1
          }
          
          Write-Host "Running bootstrapper to install compilers + MKL..."
          $installLogDir = Join-Path $env:RUNNER_TEMP "install_logs"
          New-Item -ItemType Directory -Path $installLogDir -Force | Out-Null
          
          # Use Start-Process to properly wait for installation and capture exit code
          $installProc = Start-Process -FilePath $bootstrapper -ArgumentList "-s", "--action", "install", "--config", $configFile, "--log-dir", $installLogDir, "--eula", "accept" -Wait -PassThru -NoNewWindow
          if ($installProc.ExitCode -ne 0) {
            Write-Host "Installation log contents:"
            Get-ChildItem $installLogDir -Filter "*.log" | ForEach-Object {
              Write-Host "Log file: $($_.Name)"
              Get-Content $_.FullName -Tail 30
            }
            Write-Error "oneAPI installation failed with exit code $($installProc.ExitCode)"
            exit 1
          }
          
          Write-Host "oneAPI installation completed successfully"

      - name: Set MKL environment for CMake
        run: |
          # Prefer existing MKLROOT; otherwise probe under ONEAPI_ROOT\mkl\*
          function Resolve-MklRoot {
            param([string]$OneApiRoot)
            if ($env:MKLROOT -and (Test-Path $env:MKLROOT)) { return $env:MKLROOT }
            $candidate = Join-Path $OneApiRoot "mkl\latest"
            if (Test-Path $candidate) { return $candidate }
            $versions = Get-ChildItem -Path (Join-Path $OneApiRoot "mkl") -Directory -ErrorAction SilentlyContinue | Sort-Object Name -Descending
            foreach ($v in $versions) {
              $cmakePath = Join-Path $v.FullName "lib\cmake\mkl"
              if (Test-Path $cmakePath) { return $v.FullName }
            }
            return $null
          }

          $mklRoot = Resolve-MklRoot -OneApiRoot $env:ONEAPI_ROOT
          if (-not $mklRoot) {
            Write-Error "MKL not found under $env:ONEAPI_ROOT\mkl. Ensure oneAPI Base/HPC kit with MKL is installed."
            exit 1
          }

          $env:MKLROOT = $mklRoot
          $prefix = Join-Path $mklRoot "lib\cmake\mkl"
          if (-not (Test-Path $prefix)) {
            Write-Error "MKL CMake package dir not found at $prefix"
            exit 1
          }

          $env:CMAKE_PREFIX_PATH = "$prefix;$env:CMAKE_PREFIX_PATH"

          "MKLROOT=$mklRoot" | Out-File -FilePath $env:GITHUB_ENV -Append
          "CMAKE_PREFIX_PATH=$($env:CMAKE_PREFIX_PATH)" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Install build tools (cmake, ninja)
        run: |
          choco install --no-progress -y cmake ninja

      - name: Verify oneAPI
        run: |
          if (-not (Test-Path "$env:ONEAPI_ROOT\setvars.bat")) {
            Write-Error "setvars.bat not found at $env:ONEAPI_ROOT\setvars.bat"
          }

      - name: Refresh QE source (no patch)
        run: |
          pwsh -NoProfile -ExecutionPolicy Bypass `
            -File "$env:QE_ROOT\scripts\refresh_qe_source.ps1" -NoPatch

      - name: Apply QE patches
        run: |
          pwsh -NoProfile -ExecutionPolicy Bypass `
            -File "$env:QE_ROOT\scripts\apply_qe_patches.ps1" `
            -QeDir "$env:QE_SRC" `
            -PatchDir "$env:QE_ROOT\patches"

      - name: Build QE (oneAPI, no MPI)
        run: |
          pwsh -NoProfile -ExecutionPolicy Bypass `
            -File "$env:QE_ROOT\scripts\build_qe_win_oneapi.ps1" -NoMpi

