name: QE build (Windows, Intel + .obj→.o wrapper)

on:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/qe-windows-intel.yml'
      - 'toolchains/quantum_espresso/windows/**'
      - 'toolchains/quantum_espresso/README.md'
  pull_request:
    branches: [ main ]
    paths:
      - '.github/workflows/qe-windows-intel.yml'
      - 'toolchains/quantum_espresso/windows/**'
      - 'toolchains/quantum_espresso/README.md'

jobs:
  build-qe-windows-intel:
    name: QE 7.5 build (windows-latest, Intel classic)
    runs-on: windows-latest

    env:
      QE_VERSION: "qe-7.5"
      QE_TARBALL_URL: "https://gitlab.com/QEF/q-e/-/archive/qe-7.5/q-e-qe-7.5.tar.gz"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 设置 QE_SRC_DIR / QE_PREFIX，统一用 /c/... 方便在 bash 里用
      - name: Set up QE paths
        shell: bash
        run: |
          echo "QE_SRC_DIR=/c/q-e-src" >> "$GITHUB_ENV"
          echo "QE_PREFIX=/c/qe-install" >> "$GITHUB_ENV"

      # 安装 Intel oneAPI Fortran（classic）编译器
      - name: Setup Intel Fortran (classic)
        uses: fortran-lang/setup-fortran@v1
        with:
          compiler: intel-classic
          version: '2021.10'
          update-environment: true
          cache: true

      - name: Show compilers
        shell: bash
        run: |
          echo "FC=$FC"
          echo "CC=$CC"
          echo "CXX=$CXX"
          command -v ifort  || echo "ifort not in PATH"
          command -v icl    || echo "icl not in PATH"
          command -v ar     || echo "ar not in PATH (will be needed by wrapper)"

      - name: Download and unpack QE
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
          QE_TARBALL_URL: ${{ env.QE_TARBALL_URL }}
        run: |
          echo "Using QE_SRC_DIR=$QE_SRC_DIR"
          mkdir -p "$(dirname "$QE_SRC_DIR")"
          cd "$(dirname "$QE_SRC_DIR")"

          curl -L "$QE_TARBALL_URL" -o qe.tar.gz
          tar -xzf qe.tar.gz
          rm qe.tar.gz

          EXTRACTED=$(find . -maxdepth 1 -type d -name "q-e-qe-7.5*" | head -1)
          if [ -z "$EXTRACTED" ]; then
            echo "Failed to find extracted QE source directory"
            ls -la
            exit 1
          fi

          rm -rf "$QE_SRC_DIR"
          mv "$EXTRACTED" "$QE_SRC_DIR"

          echo "QE source extracted to: $QE_SRC_DIR"
          ls -la "$QE_SRC_DIR" | head -40
          test -f "$QE_SRC_DIR/configure" || (echo "configure script not found!" && exit 1)

      # 关键：AR wrapper，把当前目录的 .obj 全部重命名为 .o，再调用真正的 ar
      - name: Prepare AR wrapper (.obj → .o)
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
        run: |
          cd "$QE_SRC_DIR"
          cat > ar-wrapper.sh << 'EOF'
          #!/usr/bin/env bash
          set -e
          # 确保没有 .obj 时不会出错
          shopt -s nullglob

          # 把当前目录下所有 .obj 重命名为同名 .o（仅当 .o 不存在时）
          for obj in *.obj; do
            [ -e "$obj" ] || continue
            base="${obj%.obj}"
            if [ ! -f "$base.o" ]; then
              mv "$obj" "$base.o"
            fi
          done

          # 调用真正的 ar（来自 Git for Windows / MinGW 等）
          ar "$@"
          EOF

          chmod +x ar-wrapper.sh
          echo "Created AR wrapper:"
          sed -n '1,40p' ar-wrapper.sh

      - name: Configure QE (serial, Intel compilers)
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
        run: |
          cd "$QE_SRC_DIR"

          # 使用 AR wrapper；不显式指定 BLAS/FFT，走 internal BLAS/LAPACK/FFTW
          AR="$PWD/ar-wrapper.sh" \
          ./install/configure \
            F90=ifort \
            MPIF90=ifort \
            CC=icl

          echo "---- make.inc (top) ----"
          sed -n '1,80p' make.inc || true

      # 跳过 GPU/devxlib（libcuda），避免 ./gcc 之类的奇怪调用
      - name: Skip devxlib (libcuda)
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
        run: |
          cd "$QE_SRC_DIR"
          mkdir -p install
          touch install/libcuda_devxlib
          echo "Created install/libcuda_devxlib to skip devxlib build"

      - name: Build QE (pw.x only)
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
        run: |
          cd "$QE_SRC_DIR"

          # 不要 -j 太大，避免 Windows 下奇怪竞态
          make pw -j2

          echo "Listing PW/src after build:"
          ls -la PW/src

      - name: Package pw.x.exe
        shell: bash
        env:
          QE_SRC_DIR: ${{ env.QE_SRC_DIR }}
          QE_PREFIX: ${{ env.QE_PREFIX }}
        run: |
          cd "$QE_SRC_DIR"

          # 在 Windows 下，实际文件一般叫 pw.x.exe
          if [ -f PW/src/pw.x.exe ]; then
            BIN="PW/src/pw.x.exe"
          elif [ -f PW/src/pw.x ]; then
            BIN="PW/src/pw.x"
          else
            echo "pw.x[.exe] not found after build"
            ls -la PW/src
            exit 1
          fi

          mkdir -p "$QE_PREFIX/bin"
          cp "$BIN" "$QE_PREFIX/bin/pw.x.exe"

          echo "Installed files under $QE_PREFIX:"
          ls -R "$QE_PREFIX" || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: qe-${{ env.QE_VERSION }}-windows-intel
          # 注意：这里要用 Windows 风格路径
          path: C:\qe-install
